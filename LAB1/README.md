Node.js - Лабораторна робота 1

Виконав: Добридник Дмитро ІК-03

### _Тема: Знайомство з середовищем Node.js_

#### Відпові на контрольні питання:

<u>_1. Чи є різниця між виконанням Javascript в браузері та в середовищі Node.js?_</u>

Так, є деякі різниці між виконанням JavaScript в браузері та в середовищі Node.js.

Основна різниця полягає в тому, що браузер та Node.js використовують різні середовища виконання JavaScript. Браузери використовують середовище виконання JavaScript, що називається "рендеринговий двигун", який призначений для візуалізації сторінок у веб-браузерах та підтримки клієнтської взаємодії з користувачем, такої як обробка подій, робота з документом тощо. У той же час, Node.js використовує середовище виконання JavaScript, що називається "засоби виконання на стороні сервера", який призначений для виконання серверних процесів та роботи з файловою системою, мережевими запитами, базами даних та іншими інфраструктурними задачами.
Окрім того, браузер та Node.js мають різні набори API та бібліотек. Наприклад, браузер має API для роботи з DOM та обробки подій, тоді як Node.js має API для роботи з файловою системою, мережевими запитами та іншими інфраструктурними задачами.

Також варто зазначити, що браузер та Node.js можуть виконувати деякі операції JavaScript по-різному. Наприклад, в браузері можна взаємодіяти з графікою та обробляти клієнтські події, тоді як Node.js може взаємодіяти з файловою системою та мережевими запитами. Отже, виконання JavaScript в браузері та в середовищі Node.js має свої відмінності та специфічність залежно від того, яку роль відіграє JavaScript у конкретному контексті.

---

<u>_2. Назвіть основні типи даних в JavaScript?_</u>

JavaScript має наступні основні типи даних:

1. Примітивні типи даних:
   - Числа **(number)** - цілі та дробові числа
   - Рядки **(string)** - послідовності символів
   - Булеві значення **(boolean)** - true або false
   - **Symbol** - примітивний тип даних (новий тип даних який появився в специфікації ES6)
   - **null** - вказує на відсутність значення
   - **undefined** - вказує на те, що змінна або властивість має значення, які не були призначені
2. Об'єкти:
   - Об'єкти **(object)** - асоціативні масиви ключ-значення
   - Функції **(function)** - об'єкти, які можуть бути викликані
   - Масиви **(array)** - упорядковані списки значень
   - Регулярні вирази **(regular expression)** - шаблони для знаходження та заміни тексту

Важливо зауважити, що примітивні типи даних в JavaScript передаються за значенням, тоді як об'єкти передаються за посиланням. Це означає, що коли примітивний тип даних копіюється або передається в якості аргументу функції, створюється нова копія зі своїм власним значенням. А коли об'єкт копіюється або передається, створюється нове посилання на той самий об'єкт.

---

<u>_3. Як працює замикання (closure) в Javascript?_</u>

Замикання (closure) - це функція, яка зберігає доступ до змінних, що належать зовнішньому контексту, навіть після того, як цей контекст закінчив своє виконання.

У JavaScript замикання створюється тоді, коли функція визначається всередині іншої функції, і має доступ до змінних, які належать зовнішньому контексту. Наприклад:

```JavaScript
  function outerFunction() {
    var outerVariable = "I am outside!";
    function innerFunction() {
      console.log(outerVariable);
    }
    return innerFunction;
  }

  var innerFunc = outerFunction();
  innerFunc(); // "I am outside!"
```

У цьому прикладі `innerFunction` - це внутрішня функція, яка створена всередині `outerFunction`. `innerFunction` має доступ до змінної `outerVariable`, яка належить зовнішньому контексту outerFunction. Хоча `outerFunction` вже закінчила своє виконання, `innerFunction` все ще може отримувати доступ до `outerVariable`, оскільки вона зберегла посилання на змінну в замиканні.

Замикання можуть бути корисні для збереження стану функції, зберігання даних між викликами функції, підтримки приватних змінних та захисту від зовнішнього змінення. Вони також широко використовуються в JavaScript-бібліотеках та фреймворках для створення інкапсульованих модулів та підтримки патерну проектування "модуль" (module pattern).

---

<u>_4. Назвіть основні стандартні бібліотеки Node.js._</u>

Node.js має широкий набір стандартних бібліотек, які містять функції та модулі для різних завдань. Ось декілька найважливіших стандартних бібліотек Node.js:

- **http** - ця бібліотека дозволяє створювати та обробляти HTTP запити та відповіді. Вона включає класи для створення HTTP серверів та клієнтів.
- **fs** - ця бібліотека містить функції для роботи з файловою системою, такі як читання та запис файлів, створення директорій тощо.
- **path** - ця бібліотека надає функції для роботи зі шляхами файлів та директорій.
- **os** - ця бібліотека містить функції для отримання інформації про операційну систему, таку як кількість доступної пам'яті, тип платформи тощо.
- **crypto** - ця бібліотека містить функції для роботи з криптографією, такі як гешування та шифрування даних.
- **util** - ця бібліотека містить різні корисні функції, такі як обрізка значень до певної довжини, створення клонів об'єктів, перетворення функцій у проміси тощо.
- **events** - ця бібліотека дозволяє створювати та обробляти події.
- **stream** - ця бібліотека містить функції для роботи з потоками даних, такі як читання та запис даних зі стандартних вхідних та вихідних потоків.

Ці бібліотеки можуть бути використані в проектах Node.js без необхідності встановлення додаткових залежностей. Однак, Node.js також має широкий додатковий екосистему модулів, які можуть бути встановлені з використанням менеджера пакеті

---

<u>_5. Які є способи імпортувати модулі в Node.js?_</u>

У Node.js є кілька способів імпортувати модулі:

- **require():** Це стандартний спосіб імпортувати модулі в Node.js. Використовується наступним чином:

```JavaScript
const module = require('module-name');
```

Наприклад, щоб імпортувати модуль http, необхідно використати наступний код:

```JavaScript
const http = require('http');
```

- **import:** Цей синтаксис є частиною стандарту ECMAScript та доступний з версії Node.js 14.8.0 і вище. Використовується наступним чином:

```JavaScript
import module from 'module-name';
```

Наприклад, щоб імпортувати модуль http, необхідно використати наступний код:

```JavaScript
import http from 'http';
```

Проте, щоб використовувати import, необхідно додатково налаштувати проект, включаючи встановлення Babel або використання спеціальних налаштувань Node.js.

- **import() динамічний імпорт:** Цей синтаксис дозволяє завантажувати модулі динамічно використовуючи import(). Використовується наступним чином:

```JavaScript
import('module-name')
  .then(module => {
    // do something with the module
  })
  .catch(error => {
    // handle the error
  });
```

Наприклад, щоб динамічно завантажити модуль http, необхідно використати наступний код:

```JavaScript
import('http')
  .then(http => {
    // do something with the http module
  })
  .catch(error => {
    // handle the error
  });
```

Кожен з цих способів має свої переваги та обмеження, і вибір конкретного способу залежить від конкретних потреб вашого проекту.

---

<u>_6. Як пов'язані Google Chrome / Chromium та Node.js?_</u>

Google Chrome та Chromium - це веб-браузери на основі відкритого вихідного коду, які використовують двигун рендерингу Blink для відображення веб-сторінок та вбудовують двигун V8 JavaScript для виконання скриптів на стороні клієнта.

Node.js - це серверний фреймворк на основі відкритого вихідного коду, який використовує двигун V8 JavaScript для виконання JavaScript-коду на стороні сервера. Node.js дозволяє створювати ефективні серверні додатки з використанням JavaScript.

Оскільки Node.js використовує двигун V8, який також використовується в Google Chrome та Chromium, це означає, що JavaScript-код, написаний для виконання в Node.js, може мати більшу сумісність з кодом, що виконується в браузері. Наприклад, більшість стандартних JavaScript-об'єктів та методів, які підтримуються в браузерах, також підтримуються в Node.js. Крім того, Node.js дозволяє використовувати модулі Node.js на стороні клієнта за допомогою засобів, таких як Browserify або Webpack.

Таким чином, можна сказати, що Node.js та Google Chrome / Chromium мають спільну основу - двигун V8 JavaScript - який дозволяє JavaScript-коду працювати на стороні сервера та в браузері, забезпечуючи більшу сумісність між різними типами JavaScript-додатків.

---

<u>_7. Як можна дозволити імпортувати змінні з поточного модуля в Node.js?_</u>

В Node.js для експортування змінних з поточного модуля можна використовувати об'єкт module.exports. Цей об'єкт містить те, що буде експортовано з модуля і доступно для імпорту в інших модулях.
Наприклад, для експортування змінної foo з поточного модуля можна використовувати наступний синтаксис:

```JavaScript
// module.js
const foo = 'Hello, World!';
module.exports = {
  foo: foo
};
```

У цьому прикладі об'єкт { foo: foo } експортується за допомогою module.exports. Тепер, щоб імпортувати змінну foo з іншого модуля, можна використовувати наступний синтаксис:

```JavaScript
// main.js
const module = require('./module.js');
console.log(module.foo);
```

У цьому прикладі змінна foo імпортується за допомогою require(), а потім виводиться у консоль.
Зверніть увагу, що ім'я, під яким експортується змінна, може відрізнятися від її оригінального імені. У цьому прикладі змінна foo експортується як властивість об'єкту з іменем module, що може бути будь-яким. Також можна скористатися скороченим записом:

```JavaScript
module.exports = {
  foo
};
```

Якщо потрібно експортувати більше однієї змінної, можна додавати їх як властивості об'єкту, що експортується. Для імпортування декількох змінних з поточного модуля можна використовувати наступний синтаксис:

```JavaScript
// module.js
const foo = 'Hello, World!';
const bar = 'Goodbye, World!';

module.exports = {
  foo: foo,
  bar: bar
};
```

```JavaScript
// main.js
const { foo, bar } = require('./module.js');

console.log(foo);
console.log(bar);
```
