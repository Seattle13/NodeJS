Node.js - Лабораторна робота 2

Виконав: Добридник Дмитро ІК-03

### _Тема: Робота з файлами та мережею_

#### Відпові на контрольні питання:

<u>_1. В чому різниця між setTimeout та setInterval?_</u>

`setTimeout` та `setInterval` - це два методи JavaScript, які використовуються для виконання певної функції часом.

Основна різниця між ними полягає в тому, що `setTimeout` виконує функцію один раз через певний часовий інтервал, тоді як `setInterval` виконує функцію через заданий інтервал часу, повторюючись заздалегідь встановлену кількість разів або без обмежень.

Отже, якщо ви хочете виконати функцію лише один раз через певний час, використовуйте `setTimeout`. Наприклад, якщо вам потрібно відкрити модальне вікно через 5 секунд, ви можете використовувати `setTimeout`.

```JavaScript
setTimeout(function(){
  // виконати дії через 5 секунд
}, 5000);
```

А якщо вам потрібно виконати функцію кожні 5 секунд, використовуйте `setInterval`.

```JavaScript
setInterval(function(){
  // виконати дії кожні 5 секунд
}, 5000);
```

Важливо пам'ятати, що `setInterval` може стати причиною витрати великої кількості ресурсів, якщо ви не виконуєте операції з усіма необхідними перевірками в тій же функції, що викликається `setInterval`. Тому, якщо ви використовуєте `setInterval`, переконайтеся, що ви використовуєте його з обережністю.

---

<u>_2. Що таке блокуючий код?_</u>

**Блокуючий код** - це код, який зупиняє виконання програми до тих пір, поки він не завершить своє виконання. Іншими словами, коли блокуючий код виконується, програма не може виконувати інші дії до завершення цього коду.

Найчастіше блокуючий код пов'язаний з виконанням довгих операцій, таких як завантаження великих файлів або виконання складних обчислень. Якщо такий код виконується в головному потоці виконання програми, то це може призвести до того, що інтерфейс користувача стане нереагуючим на дії користувача, і програма буде відчуватись як заморожена.

Один зі способів уникнення блокуючого коду полягає в тому, щоб виконувати його в окремому потоці виконання (так званих "робочих потоках" або "віддалених потоках"), який не заважатиме головному потоку програми. Для цього можуть використовуватися різні механізми, такі як **Web Workers** або **Asynchronous JavaScript** and **XML (AJAX)** запити. Іншим способом є використання асинхронного коду та викликів зворотного виклику (callback functions), що дозволяють програмі продовжувати виконуватися, поки виконується довгий процес, і потім повертатися до нього, коли він завершиться.

Загальною ознакою блокуючого коду є те, що під час його виконання програма зупиняється і не може продовжувати своє виконання до завершення цього коду. Ось декілька прикладів блокуючого коду:

- **Операції введення-виведення в Node.js**

```JavaScript
const fs = require('fs');
const data = fs.readFileSync('/path/to/file');
console.log(data);
```

У цьому прикладі метод `readFileSync` блокує виконання програми до тих пір, поки не буде прочитано весь файл з диска, що може зайняти деякий час, особливо якщо файл є великим.

- **Виконання довгих обчислень**

```JavaScript
function fibonacci(num) {
  if (num === 0 || num === 1) {
    return num;
  } else {
    return fibonacci(num - 1) + fibonacci(num - 2);
  }
}
console.log(fibonacci(40));
```

У цьому прикладі функція `fibonacci` використовує рекурсію для обчислення числа Фібоначчі. Це може зайняти багато часу для великих чисел, і під час виконання програма зупиняється.

- **Очікування на відповідь від сервера**

```JavaScript
const response = fetch('https://example.com/api/data');
const data = response.json();
console.log(data);
```

У цьому прикладі метод `fetch` виконує запит до сервера для отримання даних, а метод `json` повертає відповідь у вигляді об'єкта JavaScript. Оскільки запит до сервера може зайняти час, під час виконання програма зупиняється до отримання відповіді від сервера.

Дані приклади демонструють, як блокуючий код може зупиняти виконання програми до завершення довгих операцій. Для уникнення блокуючого коду можна використовувати асинхронний код і зворотні виклики, які дозволяють програмі продовжувати виконуватися під час виконання довгих операцій

---

<u>_3. Які переваги асинхронного читання з диску перед синхронним?_</u>

Асинхронне читання з диску має кілька переваг перед синхронним читанням:

1. **Не блокує виконання програми:** Під час асинхронного читання програма може продовжувати виконуватись під час читання даних з диска, тобто виконання програми не буде зупинено.
2. **Покращує продуктивність:** Асинхронне читання з диску дозволяє програмі читати дані паралельно з виконанням інших завдань, що покращує продуктивність програми.
3. **Зменшує час очікування:** Асинхронне читання з диску дозволяє програмі робити інші роботи під час читання даних з диска, що зменшує час очікування на отримання результатів читання.
4. **Дозволяє обробляти більші об'єми даних:** Асинхронне читання з диску дозволяє програмі читати більші об'єми даних без блокування виконання програми.
5. **Дозволяє працювати зі змінними швидкостями читання:** Асинхронне читання з диску дозволяє програмі працювати зі змінними швидкостями читання, тому що програма не блокується під час читання даних з диска.

Загалом, асинхронне читання з диску дозволяє програмі працювати більш ефективно і продуктивно, а також забезпечує швидше виконання завдань.

Декілька прикладів коду, де можна побачити переваги асинхронного читання з диску перед синхронним.

- **Асинхронне читання файлу**

```JavaScript
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
});
```

У цьому прикладі ми використовуємо метод `readFile()` модуля **fs** для асинхронного читання файлу. Метод `readFile()` приймає назву файлу, кодування і функцію зворотнього виклику, яка виконується після завершення читання файлу. Приклад показує, що після завантаження файлу ми можемо використовувати його данні асинхронно, виконуючи інші операції або запускаючи інші функції.

- **Синхронне читання файлу**

```JavaScript
const fs = require('fs');

try {
  const data = fs.readFileSync('file.txt', 'utf8');
  console.log(data);
} catch (err) {
  console.error(err);
}
```

У цьому прикладі ми використовуємо метод `readFileSync()` модуля **fs** для синхронного читання файлу. Метод `readFileSync()` приймає назву файлу і кодування. Якщо під час читання файлу виникає помилка, вона зберігається у змінній `err`. Основна проблема з синхронним читанням файлу полягає в тому, що воно блокує виконання програми до завершення операції читання файлу. Тому, якщо читання файлу займає багато часу, програма буде неефективною та повільною.

Отже, асинхронне читання файлів з диску має перевагу перед синхронним, оскільки дозволяє програмі продовжувати своє виконання під час чекання на завантаження файлу з диску. Також асинхронний код забезпечує більшу ефективність, тому що він дозволяє виконувати інші операції під час завантаження файлу з диску, тим самим зменшуючи час виконання програми.

Наприклад, якщо у нас є веб-сервер, який повинен обробляти запити та відправляти відповіді, синхронне читання файлів може заблокувати обробку інших запитів до завершення операції читання файлу. Але асинхронне читання дозволить обробляти запити під час завантаження файлів з диску, що зробить веб-сервер більш ефективним та швидким.

---

<u>_4. Опишіть різницю між Callbacks API, Promise АРІ та async / avait._</u>

Callback API, Promise API та async/await є різними способами обробки асинхронних операцій у JavaScript.

- **Callbacks API** - це старіший підхід до обробки асинхронних операцій в JavaScript. Зазвичай він використовується для виклику функції зворотного виклику після завершення асинхронної операції. Callbacks API може бути важко читати і розуміти, коли виконується багато асинхронних операцій, оскільки код вказується відступами, що може призвести до так званого "callback hell" (або "інферно зворотнього виклику").

```JavaScript
function fetchData(callback) {
  setTimeout(() => {
    callback('data received');
  }, 2000);
}

fetchData((data) => {
  console.log(data); // 'data received'
});
```

- **Promise API** - є новішим підходом до обробки асинхронних операцій в JavaScript, який був доданий до мови у стандарті ECMAScript 2015. Promise API дозволяє використовувати обіцянки (Promises), щоб представляти асинхронні операції, які можуть бути виконані в майбутньому. Обіцянки є об'єктами, що можуть перебувати у трьох станах: "виконано успішно" (fulfilled), "виконано з помилкою" (rejected) або "в очікуванні" (pending). Promise API дозволяє збільшити читабельність коду, зменшити кількість зворотних викликів та полегшити обробку помилок.

```JavaScript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('data received');
    }, 2000);
  });
}

fetchData()
  .then((data) => {
    console.log(data); // 'data received'
  })
  .catch((error) => {
    console.log(error);
  });
```

- **async/await** - це синтаксичний цукор, який був доданий до JavaScript у стандарті ECMAScript 2017. async/await дозволяє використовувати ключові слова async та await для створення більш читабельного коду для асинхронних операцій. Ключове слово async використовується для оголошення функції, яка повертає обіцянку, тоді як ключове слово await використовується для очікування на виконання асинхронної операції, перед тим як продовжити виконання наступного рядка коду.

```JavaScript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('data received');
    }, 2000);
  });
}

async function getData() {
  try {
    const data = await fetchData();
    console.log(data); // 'data received'
  } catch (error) {
    console.log(error);
  }
}

getData();
```

Кожен з цих методів має свої переваги та недоліки, тому розробники повинні вибирати метод, який найбільше відповідає їх потребам та вимогам проекту.

---

<u>_5. Як обробляються помилки при використанні Promise АРІ?_</u>

При використанні **Promise АРІ** помилки обробляються за допомогою методів `catch()` та `finally()`. Якщо виконання обіцянки завершиться успішно, то виконується метод then(). Якщо обіцянка не виконується успішно, то виконується метод `catch()`, який дозволяє обробити помилку. Крім того, метод `finally()` виконується завжди, незалежно від того, чи була обіцянка виконана успішно чи з помилкою.

Наприклад, розглянемо приклад коду з Promise, який викликає асинхронну функцію та обробляє можливі помилки:

```JavaScript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const randomNum = Math.floor(Math.random() * 10);
      if (randomNum > 5) {
        resolve('data received');
      } else {
        reject(new Error('Error fetching data'));
      }
    }, 2000);
  });
}

fetchData()
  .then((data) => {
    console.log(data); // 'data received'
  })
  .catch((error) => {
    console.log(error.message); // 'Error fetching data'
  })
  .finally(() => {
    console.log('Fetching data completed'); // 'Fetching data completed'
  });
```

У цьому прикладі функція `fetchData()` повертає Promise, який може бути виконаний успішно або з помилкою в залежності від того, чи є випадкове число більше 5. Якщо Promise виконується успішно, то виконується метод `then()`, який виводить отримані дані в консоль. Якщо Promise не виконується успішно, то виконується метод `catch()`, який виводить помилку в консоль. Метод `finally()` виконується завжди, незалежно від того, чи була обіцянка виконана успішно чи з помилкою. У даному випадку, метод `finally()` виводить повідомлення про завершення виконання операції.

---

<u>_6. Як створити директорію через модуль fs? За що відповідає параметр mode?_</u>

Для створення директорії в Node.js можна використати модуль **fs** (File System). Для цього необхідно використовувати метод `mkdir()` модуля **fs**.

Наприклад, так можна створити директорію з назвою **"newDirectory"**:

```JavaScript
const fs = require('fs');

fs.mkdir('newDirectory', (err) => {
  if (err) {
    console.error(err);
  } else {
    console.log('Directory created successfully!');
  }
});
```

У цьому прикладі використовується метод `mkdir()` модуля fs, який створює директорію з заданою назвою. Параметр err містить будь-яку помилку, яка може виникнути під час виконання функції. Також, метод `mkdir()` приймає додатковий параметр `mode`, який дозволяє задати права доступу до створеної директорії. Параметр `mode` - це число, яке відображає права доступу до файлу або директорії, що створюється. За замовчуванням, якщо параметр mode не вказано, то права доступу ставляться відповідно до налаштувань файлової системи.

Наприклад, так можна створити директорію з назвою **"newDirectory"** та з правами доступу **755**:

```JavaScript
const fs = require('fs');

fs.mkdir('newDirectory', 0o755, (err) => {
  if (err) {
    console.error(err);
  } else {
    console.log('Directory created successfully!');
  }
});
```

У цьому прикладі параметр `mode` вказаний як **0o755**, що відповідає правам доступу **rwxr-xr-x**. Це означає, що власник директорії має права на читання, запис та виконання, а решта користувачів мають права на читання та виконання.
